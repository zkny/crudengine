// Generated by CoffeeScript 2.5.1
(function() {
  var CrudEngine, Router, autopopulate, express, fs, load, mongoose, path;

  express = require('express');

  mongoose = require('mongoose');

  autopopulate = require('mongoose-autopopulate');

  fs = require('fs');

  path = require('path');

  ({load} = require('protobufjs'));

  Router = express.Router();

  CrudEngine = (function() {
    class CrudEngine {
      constructor(SchemaDIR1, ServiceDIR1) {
        var ModelName, PropertyDescription, PropertyName, Schema, SchemaDIR, SchemaFile, SchemaFileArray, SchemaName, ServiceDIR, ServiceFile, ServiceFileArray, ServiceName, i, index, item, j, k, key, len, len1, len2, model, modelname, options, ref, ref1, ref2, schema, subheaders, tmp, value;
        this.GenerateProto = this.GenerateProto.bind(this);
        this.GetCorrectType = this.GetCorrectType.bind(this);
        this.GetDeclinedReadFields = this.GetDeclinedReadFields.bind(this);
        this.GetDeclinedWriteFields = this.GetDeclinedWriteFields.bind(this);
        this.GetProjection = this.GetProjection.bind(this);
        this.GetHeaders = this.GetHeaders.bind(this);
        // Azert Promise, hogy lehessen rendes error handlinget csinalni vele, ha kesobb bovitjuk
        this.addMiddleware = this.addMiddleware.bind(this);
        this.SchemaDIR = SchemaDIR1;
        this.ServiceDIR = ServiceDIR1;
        ServiceDIR = this.ServiceDIR;
        SchemaDIR = this.SchemaDIR;
        this.Middlewares = {};
        SchemaFileArray = fs.readdirSync(SchemaDIR);
        if (ServiceDIR) {
          ServiceFileArray = fs.readdirSync(ServiceDIR);
          for (i = 0, len = ServiceFileArray.length; i < len; i++) {
            ServiceFile = ServiceFileArray[i];
            if (ServiceFile === '.DS_Store' || ServiceFile.includes('.map')) {
              continue;
            }
            ServiceName = ServiceFile.replace('.js', '').replace('.ts', '').replace('coffee', '');
            this.Services[ServiceName] = require(`${ServiceDIR}/${ServiceFile}`);
          }
        }
        for (j = 0, len1 = SchemaFileArray.length; j < len1; j++) {
          SchemaFile = SchemaFileArray[j];
          if (SchemaFile === '.DS_Store' || SchemaFile.includes('.map')) {
            continue;
          }
          SchemaName = SchemaFile.replace('.js', '').replace('.ts', '').replace('coffee', '');
          tmp = require(`${SchemaDIR}/${SchemaFile}`);
          options = [];
          schema = tmp.schema || tmp.default.schema;
          model = tmp.model || tmp.default.model;
          modelname = tmp.modelName || tmp.default.modelName;
          ref = schema.paths;
          for (PropertyName in ref) {
            PropertyDescription = ref[PropertyName];
            if (PropertyDescription.instance === 'Array') {
              subheaders = [];
              if (!PropertyDescription.options.ref && !PropertyDescription.caster.options.ref) {
                ref1 = PropertyDescription.options.type[0];
                for (key in ref1) {
                  value = ref1[key];
                  value.name = key;
                  subheaders.push(value);
                }
              }
              options.push({
                name: PropertyName,
                isArray: true,
                type: PropertyDescription.caster.instance,
                subheaders: subheaders,
                required: PropertyDescription.isRequired || false,
                ref: PropertyDescription.options.ref || PropertyDescription.caster.options.ref || null,
                alias: PropertyDescription.options.alias || PropertyDescription.caster.options.alias || null,
                description: PropertyDescription.options.description || PropertyDescription.caster.options.description || null,
                default: PropertyDescription.defaultValue || PropertyDescription.caster.defaultValue || null,
                minReadAuth: PropertyDescription.options.minReadAuth || PropertyDescription.caster.options.minReadAuth || 300,
                minWriteAuth: PropertyDescription.options.minWriteAuth || PropertyDescription.caster.options.minWriteAuth || 300
              });
            } else {
              options.push({
                name: PropertyName,
                isArray: false,
                type: PropertyDescription.instance,
                required: PropertyDescription.isRequired || false,
                ref: PropertyDescription.options.ref || null,
                alias: PropertyDescription.options.alias || null,
                description: PropertyDescription.options.description || null,
                default: PropertyDescription.defaultValue || null,
                minReadAuth: PropertyDescription.options.minReadAuth || 300,
                minWriteAuth: PropertyDescription.options.minWriteAuth || 300
              });
            }
          }
          this.Schema[modelname] = options;
          this.Models[modelname] = model;
          this.Middlewares[modelname] = {
            C: {},
            R: {},
            U: {},
            D: {}
          };
        }
        ref2 = this.Schema;
        // plug in ref schemas
        for (ModelName in ref2) {
          Schema = ref2[ModelName];
          for (index = k = 0, len2 = Schema.length; k < len2; index = ++k) {
            item = Schema[index];
            if (item.ref) {
              this.Schema[ModelName][index].subheaders = this.Schema[item.ref];
            }
          }
        }
        this.GenerateProto();
        // the api.proto file should be done at this point
        load(path.resolve(__dirname, './api.proto'), (error, api) => {
          if (!error) {
            return this.API = api;
          }
        });
      }

      GenerateProto() {
        var ModelName, Schema, i, id, item, len, proto, ref, type;
        proto = "package api;\nsyntax = \"proto3\";\n\n";
        ref = this.Schema;
        for (ModelName in ref) {
          Schema = ref[ModelName];
          proto += `message ${ModelName} {\n`;
          id = 1;
          for (i = 0, len = Schema.length; i < len; i++) {
            item = Schema[i];
            type = this.GetCorrectType(item);
            if (type === null) {
              continue;
            }
            proto += `\t${type} ${item.name} = ${id};\n`;
            id++;
          }
          proto += "}\n";
          proto += `message ${ModelName}s {\n\trepeated ${ModelName} ${ModelName}s = 1;\n}\n\n`;
        }
        return fs.writeFileSync(path.resolve(__dirname, './api.proto'), proto, {
          flag: "w+"
        });
      }

      GetCorrectType(item) {
        switch (item.type) {
          case 'Number':
            return 'float';
          case 'String':
            return 'string';
          case 'ObjectID':
            if (item.ref) {
              return item.ref;
            } else {
              return 'string';
            }
            break;
          default:
            return null;
        }
      }

      GetDeclinedReadFields(uId, model) {
        return new Promise((resolve, reject) => {
          if (uId === null) {
            return resolve([]);
          }
          return mongoose.model('User').findOne({
            _id: uId
          }, (error, user) => {
            return resolve(this.Schema[model].filter((field) => {
              return field.minReadAuth !== void 0 && field.minReadAuth < user.accesslevel;
            }).map((one) => {
              return one.name;
            }));
          });
        });
      }

      GetDeclinedWriteFields(uId, model) {
        return new Promise((resolve, reject) => {
          if (uId === null) {
            return resolve(null);
          }
          return mongoose.model('User').findOne({
            _id: uId
          }, (error, user) => {
            var declinedFields;
            declinedFields = this.Schema[model].filter((field) => {
              return field.minWriteAuth !== void 0 && field.minWriteAuth < user.accesslevel;
            });
            if (declinedFields.filter((one) => {
              return one.required;
            }).length) {
              return resolve(null);
            }
            return resolve(declinedFields.map((one) => {
              return one.name;
            }));
          });
        });
      }

      async GetProjection(uId, model, fields = [], include = false) {
        var projection;
        projection = {};
        if (include) {
          this.Schema[model].map((one) => {
            if (!fields.includes(one.name)) {
              return projection[one.name] = 0;
            }
          });
        } else {
          fields.map((one) => {
            return projection[one] = 0;
          });
        }
        ((await this.GetDeclinedReadFields(uId, model))).map((one) => {
          return projection[one.name] = 0;
        });
        if (Object.keys(projection).length === 0) {
          return {
            __v: 0
          };
        } else {
          return projection;
        }
      }

      GetHeaders(model) {
        var Headers, i, item, j, len, len1, ref, ref1, subheaders, subitem;
        Headers = []; // { name, key, subheaders }
        ref = this.Schema[model];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          if (!item.alias) {
            continue;
          }
          if (!item.isArray && !item.ref) {
            Headers.push({
              name: item.alias,
              key: item.name,
              description: item.description
            });
          } else {
            subheaders = [];
            ref1 = item.subheaders;
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              subitem = ref1[j];
              subheaders.push({
                name: subitem.alias,
                key: subitem.name,
                description: subitem.description
              });
            }
            Headers.push({
              name: item.alias,
              key: item.name,
              description: item.description,
              subheaders: subheaders
            });
          }
        }
        return Headers;
      }

      GenerateRoutes() {
        Router.get('/schema', (req, res) => {
          return res.send(this.Schema);
        });
        // Generate the crud routes for each model
        Router.get('/getter/:service/:fun', (req, res) => {
          return this.Services[req.params.service][req.params.fun].call(null, {
            params: req.query
          }).then(function(data) {
            return res.send(data);
          }).catch(function(error) {
            return res.status(500).send(error);
          });
        });
        Router.post('/runner/:service/:fun', (req, res) => {
          return this.Services[req.params.service][req.params.fun].call(null, {
            params: req.body
          }).then(function(data) {
            return res.send(data);
          }).catch(function(error) {
            return res.status(500).send(error);
          });
        });
        Router.use('/protofile', express.static(path.resolve(__dirname, './api.proto')));
        Router.get('/proto/:model', async(req, res) => {
          var Headers, MFunctions, projection;
          if (!req.query.filter) {
            req.query.filter = "{}";
          }
          if (!req.query.sort) {
            req.query.sort = "{}";
          }
          Headers = this.GetHeaders(req.params.model);
          MFunctions = this.Middlewares[req.params.model].R;
          projection = (await this.GetProjection((req.user ? req.user._id : null), req.params.model));
          if (MFunctions.before && (await eval(MFunctions.before)) === true) {
            return;
          }
          return mongoose.model(req.params.model).find(JSON.parse(req.query.filter), projection).sort(JSON.parse(req.query.sort)).skip(req.query.skip || 0).limit(req.query.limit).then(async(results) => {
            var ProtoType, buffer, message;
            if (MFunctions.after && (await eval(MFunctions.after)) === true) {
              return;
            }
            ProtoType = this.API.lookupType(`api.${req.params.model}s`);
            message = ProtoType.fromObject({
              [`${req.params.model}s`]: results
            });
            buffer = ProtoType.encode(message).finish();
            return res.send(buffer);
          }).catch((error) => {
            return res.status(500).send(error);
          });
        });
        Router.get('/tableheaders/:model', (req, res) => {
          return res.send(this.GetHeaders(req.params.model));
        });
        Router.get('/table/:model', async(req, res) => {
          var Headers, MFunctions, projection;
          if (!req.query.filter) {
            req.query.filter = "{}";
          }
          if (!req.query.sort) {
            req.query.sort = "{}";
          }
          Headers = this.GetHeaders(req.params.model);
          MFunctions = this.Middlewares[req.params.model].R;
          projection = (await this.GetProjection((req.user ? req.user._id : null), req.params.model));
          if (MFunctions.before && (await eval(MFunctions.before)) === true) {
            return;
          }
          return mongoose.model(req.params.model).find(JSON.parse(req.query.filter), projection).sort(JSON.parse(req.query.sort)).skip(req.query.skip || 0).limit(req.query.limit).then(async(results) => {
            if (MFunctions.after && (await eval(MFunctions.after)) === true) {
              return;
            }
            return res.send({
              Headers,
              Data: results
            });
          }).catch((error) => {
            return res.status(500).send(error);
          });
        });
        Router.get('/:model/find', async(req, res) => {
          var MFunctions, projection;
          if (!req.query.filter) {
            req.query.filter = "{}";
          }
          if (!req.query.sort) {
            req.query.sort = "{}";
          }
          MFunctions = this.Middlewares[req.params.model].R;
          projection = (await this.GetProjection((req.user ? req.user._id : null), req.params.model, req.query.projection, false));
          if (MFunctions.before && (await eval(MFunctions.before)) === true) {
            return;
          }
          return mongoose.model(req.params.model).find(JSON.parse(req.query.filter), projection).sort(JSON.parse(req.query.sort)).skip(req.query.skip || 0).limit(req.query.limit).then(async(results) => {
            if (MFunctions.after && (await eval(MFunctions.after)) === true) {
              return;
            }
            return res.send(results);
          }).catch((error) => {
            return res.status(500).send(error);
          });
        });
        Router.get("/:model/:id", async(req, res) => {
          var MFunctions, projection;
          MFunctions = this.Middlewares[req.params.model].R;
          projection = (await this.GetProjection((req.user ? req.user._id : null), req.params.model, req.query.projection, false));
          if (MFunctions.before && (await eval(MFunctions.before)) === true) {
            return;
          }
          return mongoose.model(req.params.model).findOne({
            _id: req.params.id
          }, projection, async(error, results) => {
            if (error) {
              return res.status(500).send(error);
            }
            if (MFunctions.after && (await eval(MFunctions.after)) === true) {
              return;
            }
            return res.send(results);
          });
        });
        Router.post("/:model", async(req, res) => {
          var MFunctions, Mod, declinedFields, results;
          MFunctions = this.Middlewares[req.params.model].C;
          declinedFields = (await this.GetDeclinedWriteFields((req.user ? req.user._id : null), req.params.model));
          if (declinedFields === null) {
            return res.status(500).send('EPERM');
          }
          declinedFields.map((one) => {
            return delete req.body[one];
          });
          if (MFunctions.before && (await eval(MFunctions.before)) === true) {
            return;
          }
          Mod = mongoose.model(req.params.model);
          results = new Mod(req.body);
          return results.save(async(error, results) => {
            if (error) {
              return res.status(500).send(error);
            }
            if (MFunctions.after && (await eval(MFunctions.after)) === true) {
              return;
            }
            return res.send(results);
          });
        });
        Router.patch("/:model", async(req, res) => {
          var MFunctions, declinedFields;
          MFunctions = this.Middlewares[req.params.model].U;
          declinedFields = (await this.GetDeclinedWriteFields((req.user ? req.user._id : null), req.params.model));
          if (declinedFields === null) {
            return res.status(500).send('EPERM');
          }
          declinedFields.map((one) => {
            return delete req.body[one];
          });
          if (MFunctions.before && (await eval(MFunctions.before)) === true) {
            return;
          }
          return mongoose.model(req.params.model).updateOne({
            _id: req.body._id
          }, req.body, async(error, results) => {
            if (error) {
              return res.status(500).send(error);
            }
            if (MFunctions.after && (await eval(MFunctions.after)) === true) {
              return;
            }
            return res.send(results);
          });
        });
        Router.delete("/:model/:id", async(req, res) => {
          var MFunctions, declinedFields;
          MFunctions = this.Middlewares[req.params.model].D;
          declinedFields = (await this.GetDeclinedWriteFields((req.user ? req.user._id : null), req.params.model));
          if (declinedFields === null || declinedFields.length) {
            return res.status(500).send('EPERM');
          }
          if (MFunctions.before && (await eval(MFunctions.before)) === true) {
            return;
          }
          return mongoose.model(req.params.model).deleteOne({
            _id: req.params.id
          }, async(error) => {
            if (error) {
              return res.status(500).send(error);
            }
            if (MFunctions.after && (await eval(MFunctions.after)) === true) {
              return;
            }
            return res.send('ok');
          });
        });
        return Router;
      }

      addMiddleware(modelname, operation, timing, middlewareFunction) {
        return new Promise((resolve, reject) => {
          if (!this.Middlewares[modelname]) {
            return reject(new Error(`No model found with name: ${modelname}`));
          }
          if (!this.Operations.some((o) => {
            return o === operation;
          })) {
            return reject(new Error(`Operation should be one of: ${this.Operations}`));
          }
          if (!this.Timings.some((o) => {
            return o === timing;
          })) {
            return reject(new Error(`Timing should be one of: ${this.Timings}`));
          }
          this.Middlewares[modelname][operation][timing] = `(${middlewareFunction.toString()})()`;
          return resolve('Middleware added');
        });
      }

    };

    CrudEngine.prototype.Schema = {};

    CrudEngine.prototype.Services = {};

    CrudEngine.prototype.Models = {};

    CrudEngine.prototype.Operations = ['C', 'R', 'U', 'D'];

    CrudEngine.prototype.Timings = ['after', 'before'];

    CrudEngine.prototype.API = false;

    return CrudEngine;

  }).call(this);

  module.exports = CrudEngine;

}).call(this);
